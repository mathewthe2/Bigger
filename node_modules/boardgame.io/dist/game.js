(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Moves = factory());
}(this, (function () { 'use strict';

function __$styleInject(css, returnValue) {
  if (typeof document === 'undefined') {
    return returnValue;
  }
  css = css || '';
  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';
  head.appendChild(style);
  
  if (style.styleSheet){
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
  return returnValue;
}

/*
 * Copyright 2017 Google Inc.
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/*
 * Game
 *
 * Helper to generate the game move reducer. The returned
 * reducer has the following signature:
 *
 * (G, action, ctx) => {}
 *
 * You can roll your own if you like, or use any Redux
 * addon to generate such a reducer.
 *
 * The convention used in this framework is to
 * have action.type contain the name of the move, and
 * action.args contain any additional arguments as an
 * Array.
 *
 * Args:
 *   obj.setup - Function that returns the initial state of G.
 *   obj.moves - A dictionary of move functions.
 *   obj.playerView - A function that returns a
 *                    derivative of G suitable for
 *                    showing the specified player.
 *
 * Usage:
 *
 * Game({
 *   setup: (numPlayers) => {
 *     const G = {...};
 *     return G;
 *   },
 *   moves: {
 *     'moveWithoutArgs': (G, ctx) => {
 *       return Object.assign({}, G, ...);
 *     },
 *     'moveWithArgs': (G, ctx, arg0, arg1) => {
 *       return Object.assign({}, G, ...);
 *     }
 *   },
 *   winner: (G, ctx) => { ... },
 *   playerView: (G, ctx, player) => { ... },
 * })
 */
function Game$1(_ref) {
  var setup = _ref.setup,
      moves = _ref.moves,
      victory = _ref.victory,
      playerView = _ref.playerView;

  if (!setup) setup = function setup() {
    return {};
  };
  if (!moves) moves = {};
  if (!victory) victory = function victory() {
    return null;
  };
  if (!playerView) playerView = function playerView(G) {
    return G;
  };

  return {
    setup: setup,
    victory: victory,
    playerView: playerView,
    moveNames: Object.getOwnPropertyNames(moves),
    reducer: function reducer(G, action, ctx) {
      if (moves.hasOwnProperty(action.type)) {
        var context = moves[action.type];
        var args = [G, ctx].concat(action.args);
        return moves[action.type].apply(context, args);
      }
      return G;
    }
  };
}

/*
 * Copyright 2017 Google Inc.
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

return Game$1;

})));
